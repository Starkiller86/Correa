{"ast":null,"code":"// services/socket.js\n// Servicio de WebSocket/REST para la cocina (ClientInterface y KitchenInterface)\n\nclass SocketService {\n  static getInstance() {\n    if (!SocketService.instance) {\n      SocketService.instance = new SocketService();\n    }\n    return SocketService.instance;\n  }\n  constructor() {\n    this.socket = null;\n    this.callbacks = {}; // Mapa: type -> handler\n    this.retryCount = 0;\n    const hostname = window.location.hostname;\n    this.wsUrl = `ws://${hostname}:8080`; // WS din√°mico\n    this.baseUrl = `http://${hostname}:3001`; // REST din√°mico (json-server)\n  }\n  connect() {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\n    this.socket = new WebSocket(this.wsUrl);\n    this.socket.onopen = () => {\n      this.retryCount = 0;\n    };\n    this.socket.onmessage = msg => {\n      try {\n        const data = JSON.parse(msg.data);\n        const type = data === null || data === void 0 ? void 0 : data.type;\n        if (!type) return;\n\n        // Dispara handlers registrados exactamente por tipo\n        if (this.callbacks[type]) {\n          this.callbacks[type](data);\n          return;\n        }\n\n        // üîÅ Tolerancia: si llega `kitchen:new_order` crudo, convi√©rtelo a `kitchen:update`\n        if (type.endsWith(':new_order') && data.order) {\n          const ns = type.split(':')[0]; // 'kitchen' o 'bar'\n          const payload = {\n            type: `${ns}:update`,\n            orders: Array.isArray(data.order) ? data.order : [data.order]\n          };\n          if (this.callbacks[payload.type]) this.callbacks[payload.type](payload);\n        }\n      } catch (e) {\n        console.error('‚ùå Error procesando mensaje WS:', e);\n      }\n    };\n    this.socket.onclose = () => this.scheduleReconnect();\n    this.socket.onerror = e => console.error('‚ö†Ô∏è WS error:', e);\n  }\n  scheduleReconnect() {\n    const delay = Math.min(1000 * 2 ** this.retryCount, 30000);\n    this.retryCount += 1;\n    setTimeout(() => this.connect(), delay);\n  }\n  on(type, cb) {\n    this.callbacks[type] = cb;\n  }\n  send(payload) {\n    var _this$socket;\n    if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(payload));\n    } else {\n      console.warn('WS no abierto, no se envi√≥:', payload);\n    }\n  }\n  async waitForSocketReady(retries = 6, interval = 400) {\n    for (let i = 0; i < retries; i++) {\n      var _this$socket2;\n      if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN) return;\n      await new Promise(r => setTimeout(r, interval));\n    }\n    throw new Error('WebSocket no disponible');\n  }\n\n  // ===== REST (cocina)\n  async fetchMenu() {\n    const r = await fetch(`${this.baseUrl}/dishes`);\n    return r.json();\n  }\n  async createOrder(order) {\n    const r = await fetch(`${this.baseUrl}/orders`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(order)\n    });\n    if (!r.ok) throw new Error('REST /orders fall√≥');\n    return r.json();\n  }\n  async completeOrder(orderId) {\n    const r = await fetch(`${this.baseUrl}/orders/${orderId}`, {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        status: 'completed'\n      })\n    });\n    if (!r.ok) throw new Error('REST /orders/:id fall√≥');\n    return r.json();\n  }\n}\n\n// Singleton\nSocketService.instance = null;\nexport const socket = SocketService.getInstance();\n\n/**\r\n * Inicializa subscripci√≥n POR NAMESPACE (ej: 'kitchen').\r\n * El callback SIEMPRE recibe un array de √≥rdenes.\r\n */\nexport const initializeSocketConnection = (namespace, onOrdersArray) => {\n  // Con namespace correcto\n  socket.on(`${namespace}:initial_data`, ({\n    orders\n  }) => onOrdersArray === null || onOrdersArray === void 0 ? void 0 : onOrdersArray(orders || []));\n  socket.on(`${namespace}:update`, ({\n    orders\n  }) => onOrdersArray === null || onOrdersArray === void 0 ? void 0 : onOrdersArray(orders || []));\n  socket.on(`${namespace}:new_order`, ({\n    order\n  }) => onOrdersArray === null || onOrdersArray === void 0 ? void 0 : onOrdersArray(Array.isArray(order) ? order : [order]));\n  // Seguridad: por si el server no usa namespace\n  socket.on('initial_data', ({\n    orders\n  }) => onOrdersArray === null || onOrdersArray === void 0 ? void 0 : onOrdersArray(orders || []));\n  socket.on('update', ({\n    orders\n  }) => onOrdersArray === null || onOrdersArray === void 0 ? void 0 : onOrdersArray(orders || []));\n  socket.connect();\n};\n\n// Fetch de men√∫ de cocina\nexport const fetchMenuItems = () => socket.fetchMenu();\n\n/** Crear orden POR NAMESPACE (ej: 'kitchen') */\nexport const placeNewOrderNS = async (namespace, order) => {\n  const saved = await socket.createOrder(order); // Guarda en REST\n  await socket.waitForSocketReady(); // Espera WS\n  socket.send({\n    type: `${namespace}:new_order`,\n    order: saved\n  }); // Notifica por WS\n  return saved;\n};\n\n/** Marcar completado POR NAMESPACE (ej: 'kitchen') */\nexport const markOrderAsCompletedNS = async (namespace, orderId) => {\n  await socket.completeOrder(orderId); // Actualiza en REST\n  await socket.waitForSocketReady();\n  socket.send({\n    type: `${namespace}:complete_order`,\n    orderId\n  }); // Notifica por WS\n};","map":{"version":3,"names":["SocketService","getInstance","instance","constructor","socket","callbacks","retryCount","hostname","window","location","wsUrl","baseUrl","connect","readyState","WebSocket","OPEN","onopen","onmessage","msg","data","JSON","parse","type","endsWith","order","ns","split","payload","orders","Array","isArray","e","console","error","onclose","scheduleReconnect","onerror","delay","Math","min","setTimeout","on","cb","send","_this$socket","stringify","warn","waitForSocketReady","retries","interval","i","_this$socket2","Promise","r","Error","fetchMenu","fetch","json","createOrder","method","headers","body","ok","completeOrder","orderId","status","initializeSocketConnection","namespace","onOrdersArray","fetchMenuItems","placeNewOrderNS","saved","markOrderAsCompletedNS"],"sources":["C:/Users/karen/OneDrive/Escritorio/Correa3/Correa/client/src/services/socket.js"],"sourcesContent":["// services/socket.js\r\n// Servicio de WebSocket/REST para la cocina (ClientInterface y KitchenInterface)\r\n\r\nclass SocketService {\r\n  static instance = null;\r\n\r\n  static getInstance() {\r\n    if (!SocketService.instance) {\r\n      SocketService.instance = new SocketService();\r\n    }\r\n    return SocketService.instance;\r\n  }\r\n\r\n  constructor() {\r\n    this.socket = null;\r\n    this.callbacks = {};     // Mapa: type -> handler\r\n    this.retryCount = 0;\r\n\r\n    const hostname = window.location.hostname;\r\n    this.wsUrl = `ws://${hostname}:8080`;    // WS din√°mico\r\n    this.baseUrl = `http://${hostname}:3001`; // REST din√°mico (json-server)\r\n  }\r\n\r\n  connect() {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\r\n    this.socket = new WebSocket(this.wsUrl);\r\n\r\n    this.socket.onopen = () => { this.retryCount = 0; };\r\n\r\n    this.socket.onmessage = (msg) => {\r\n      try {\r\n        const data = JSON.parse(msg.data);\r\n        const type = data?.type;\r\n        if (!type) return;\r\n\r\n        // Dispara handlers registrados exactamente por tipo\r\n        if (this.callbacks[type]) {\r\n          this.callbacks[type](data);\r\n          return;\r\n        }\r\n\r\n        // üîÅ Tolerancia: si llega `kitchen:new_order` crudo, convi√©rtelo a `kitchen:update`\r\n        if (type.endsWith(':new_order') && data.order) {\r\n          const ns = type.split(':')[0]; // 'kitchen' o 'bar'\r\n          const payload = { type: `${ns}:update`, orders: Array.isArray(data.order) ? data.order : [data.order] };\r\n          if (this.callbacks[payload.type]) this.callbacks[payload.type](payload);\r\n        }\r\n      } catch (e) {\r\n        console.error('‚ùå Error procesando mensaje WS:', e);\r\n      }\r\n    };\r\n\r\n    this.socket.onclose = () => this.scheduleReconnect();\r\n    this.socket.onerror = (e) => console.error('‚ö†Ô∏è WS error:', e);\r\n  }\r\n\r\n  scheduleReconnect() {\r\n    const delay = Math.min(1000 * (2 ** this.retryCount), 30000);\r\n    this.retryCount += 1;\r\n    setTimeout(() => this.connect(), delay);\r\n  }\r\n\r\n  on(type, cb) { this.callbacks[type] = cb; }\r\n\r\n  send(payload) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify(payload));\r\n    } else {\r\n      console.warn('WS no abierto, no se envi√≥:', payload);\r\n    }\r\n  }\r\n\r\n  async waitForSocketReady(retries = 6, interval = 400) {\r\n    for (let i = 0; i < retries; i++) {\r\n      if (this.socket?.readyState === WebSocket.OPEN) return;\r\n      await new Promise(r => setTimeout(r, interval));\r\n    }\r\n    throw new Error('WebSocket no disponible');\r\n  }\r\n\r\n  // ===== REST (cocina)\r\n  async fetchMenu() {\r\n    const r = await fetch(`${this.baseUrl}/dishes`);\r\n    return r.json();\r\n  }\r\n\r\n  async createOrder(order) {\r\n    const r = await fetch(`${this.baseUrl}/orders`, {\r\n      method: 'POST',\r\n      headers: {'Content-Type':'application/json'},\r\n      body: JSON.stringify(order),\r\n    });\r\n    if (!r.ok) throw new Error('REST /orders fall√≥');\r\n    return r.json();\r\n  }\r\n\r\n  async completeOrder(orderId) {\r\n    const r = await fetch(`${this.baseUrl}/orders/${orderId}`, {\r\n      method: 'PATCH',\r\n      headers: {'Content-Type':'application/json'},\r\n      body: JSON.stringify({ status: 'completed' }),\r\n    });\r\n    if (!r.ok) throw new Error('REST /orders/:id fall√≥');\r\n    return r.json();\r\n  }\r\n}\r\n\r\n// Singleton\r\nexport const socket = SocketService.getInstance();\r\n\r\n/**\r\n * Inicializa subscripci√≥n POR NAMESPACE (ej: 'kitchen').\r\n * El callback SIEMPRE recibe un array de √≥rdenes.\r\n */\r\nexport const initializeSocketConnection = (namespace, onOrdersArray) => {\r\n  // Con namespace correcto\r\n  socket.on(`${namespace}:initial_data`, ({ orders }) => onOrdersArray?.(orders || []));\r\n  socket.on(`${namespace}:update`,       ({ orders }) => onOrdersArray?.(orders || []));\r\n  socket.on(`${namespace}:new_order`,    ({ order })  => onOrdersArray?.(Array.isArray(order) ? order : [order]));\r\n  // Seguridad: por si el server no usa namespace\r\n  socket.on('initial_data', ({ orders }) => onOrdersArray?.(orders || []));\r\n  socket.on('update',       ({ orders }) => onOrdersArray?.(orders || []));\r\n  socket.connect();\r\n};\r\n\r\n// Fetch de men√∫ de cocina\r\nexport const fetchMenuItems = () => socket.fetchMenu();\r\n\r\n/** Crear orden POR NAMESPACE (ej: 'kitchen') */\r\nexport const placeNewOrderNS = async (namespace, order) => {\r\n  const saved = await socket.createOrder(order);    // Guarda en REST\r\n  await socket.waitForSocketReady();                // Espera WS\r\n  socket.send({ type: `${namespace}:new_order`, order: saved }); // Notifica por WS\r\n  return saved;\r\n};\r\n\r\n/** Marcar completado POR NAMESPACE (ej: 'kitchen') */\r\nexport const markOrderAsCompletedNS = async (namespace, orderId) => {\r\n  await socket.completeOrder(orderId);              // Actualiza en REST\r\n  await socket.waitForSocketReady();\r\n  socket.send({ type: `${namespace}:complete_order`, orderId }); // Notifica por WS\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}