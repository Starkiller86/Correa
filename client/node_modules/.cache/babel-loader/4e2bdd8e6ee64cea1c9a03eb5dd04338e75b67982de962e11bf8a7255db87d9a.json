{"ast":null,"code":"// services/socket.js\nclass SocketService {\n  static getInstance() {\n    if (!SocketService.instance) {\n      SocketService.instance = new SocketService();\n    }\n    return SocketService.instance;\n  }\n  constructor() {\n    this.socket = null;\n    this.callbacks = {};\n    this.retryCount = 0;\n    const hostname = window.location.hostname;\n    this.wsUrl = `ws://${hostname}:8080`;\n    this.baseUrl = `http://${hostname}:3001`;\n  }\n  connect() {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\n    this.socket = new WebSocket(this.wsUrl);\n    this.socket.onopen = () => {\n      console.log('✅ WS conectado');\n      this.retryCount = 0;\n    };\n    this.socket.onmessage = msg => {\n      try {\n        const data = JSON.parse(msg.data);\n        const type = data === null || data === void 0 ? void 0 : data.type;\n        if (!type) return;\n        if (this.callbacks[type]) {\n          this.callbacks[type](data);\n          return;\n        }\n      } catch (e) {\n        console.error('❌ Error procesando mensaje WS:', e);\n      }\n    };\n    this.socket.onclose = () => this.scheduleReconnect();\n    this.socket.onerror = e => console.error('⚠️ WS error:', e);\n  }\n  scheduleReconnect() {\n    const delay = Math.min(1000 * 2 ** this.retryCount, 30000);\n    this.retryCount += 1;\n    setTimeout(() => this.connect(), delay);\n  }\n  on(type, cb) {\n    this.callbacks[type] = cb;\n  }\n  send(payload) {\n    var _this$socket;\n    if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(payload));\n    } else {\n      console.warn('WS no abierto, no se envió:', payload);\n    }\n  }\n  async waitForSocketReady(retries = 6, interval = 400) {\n    for (let i = 0; i < retries; i++) {\n      var _this$socket2;\n      if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN) return;\n      await new Promise(r => setTimeout(r, interval));\n    }\n    throw new Error('WebSocket no disponible');\n  }\n\n  // REST\n  async fetchMenu() {\n    const r = await fetch(`${this.baseUrl}/dishes`);\n    return r.json();\n  }\n  async createOrder(order) {\n    const r = await fetch(`${this.baseUrl}/orders`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(order)\n    });\n    if (!r.ok) throw new Error('REST /orders falló');\n    return r.json();\n  }\n  async completeOrder(orderId) {\n    const r = await fetch(`${this.baseUrl}/orders/${orderId}`, {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        status: 'completed'\n      })\n    });\n    if (!r.ok) throw new Error('REST /orders/:id falló');\n    return r.json();\n  }\n}\nSocketService.instance = null;\nexport const socket = SocketService.getInstance();\n\n/**\r\n * Inicializa subscripción por namespace.\r\n */\nexport const initializeSocketConnection = (namespace, onOrdersArray) => {\n  socket.on(`${namespace}:initial_data`, ({\n    orders\n  }) => onOrdersArray === null || onOrdersArray === void 0 ? void 0 : onOrdersArray(orders || []));\n  socket.on(`${namespace}:update`, ({\n    orders\n  }) => onOrdersArray === null || onOrdersArray === void 0 ? void 0 : onOrdersArray(orders || []));\n  socket.on(`${namespace}:new_order`, ({\n    order\n  }) => {\n    onOrdersArray === null || onOrdersArray === void 0 ? void 0 : onOrdersArray(Array.isArray(order) ? order : [order]);\n  });\n  socket.connect();\n};\nexport const fetchMenuItems = () => socket.fetchMenu();\n\n/** Enviar pedido */\nexport const placeNewOrderNS = async (namespace, order) => {\n  const saved = await socket.createOrder(order);\n  await socket.waitForSocketReady();\n  socket.send({\n    type: `${namespace}:new_order`,\n    order: [saved] // siempre array\n  });\n  return saved;\n};\n\n/** Marcar completado */\nexport const markOrderAsCompletedNS = async (namespace, orderId) => {\n  const updated = await socket.completeOrder(orderId); // pedido actualizado\n  await socket.waitForSocketReady();\n  socket.send({\n    type: `${namespace}:update`,\n    orders: [updated] // enviamos pedido actualizado\n  });\n};","map":{"version":3,"names":["SocketService","getInstance","instance","constructor","socket","callbacks","retryCount","hostname","window","location","wsUrl","baseUrl","connect","readyState","WebSocket","OPEN","onopen","console","log","onmessage","msg","data","JSON","parse","type","e","error","onclose","scheduleReconnect","onerror","delay","Math","min","setTimeout","on","cb","send","payload","_this$socket","stringify","warn","waitForSocketReady","retries","interval","i","_this$socket2","Promise","r","Error","fetchMenu","fetch","json","createOrder","order","method","headers","body","ok","completeOrder","orderId","status","initializeSocketConnection","namespace","onOrdersArray","orders","Array","isArray","fetchMenuItems","placeNewOrderNS","saved","markOrderAsCompletedNS","updated"],"sources":["C:/Users/karen/OneDrive/Escritorio/Correa3/Correa/client/src/services/socket.js"],"sourcesContent":["// services/socket.js\r\nclass SocketService {\r\n  static instance = null;\r\n\r\n  static getInstance() {\r\n    if (!SocketService.instance) {\r\n      SocketService.instance = new SocketService();\r\n    }\r\n    return SocketService.instance;\r\n  }\r\n\r\n  constructor() {\r\n    this.socket = null;\r\n    this.callbacks = {};\r\n    this.retryCount = 0;\r\n\r\n    const hostname = window.location.hostname;\r\n    this.wsUrl = `ws://${hostname}:8080`;\r\n    this.baseUrl = `http://${hostname}:3001`;\r\n  }\r\n\r\n  connect() {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\r\n\r\n    this.socket = new WebSocket(this.wsUrl);\r\n\r\n    this.socket.onopen = () => {\r\n      console.log('✅ WS conectado');\r\n      this.retryCount = 0;\r\n    };\r\n\r\n    this.socket.onmessage = (msg) => {\r\n      try {\r\n        const data = JSON.parse(msg.data);\r\n        const type = data?.type;\r\n        if (!type) return;\r\n\r\n        if (this.callbacks[type]) {\r\n          this.callbacks[type](data);\r\n          return;\r\n        }\r\n      } catch (e) {\r\n        console.error('❌ Error procesando mensaje WS:', e);\r\n      }\r\n    };\r\n\r\n    this.socket.onclose = () => this.scheduleReconnect();\r\n    this.socket.onerror = (e) => console.error('⚠️ WS error:', e);\r\n  }\r\n\r\n  scheduleReconnect() {\r\n    const delay = Math.min(1000 * (2 ** this.retryCount), 30000);\r\n    this.retryCount += 1;\r\n    setTimeout(() => this.connect(), delay);\r\n  }\r\n\r\n  on(type, cb) { this.callbacks[type] = cb; }\r\n\r\n  send(payload) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify(payload));\r\n    } else {\r\n      console.warn('WS no abierto, no se envió:', payload);\r\n    }\r\n  }\r\n\r\n  async waitForSocketReady(retries = 6, interval = 400) {\r\n    for (let i = 0; i < retries; i++) {\r\n      if (this.socket?.readyState === WebSocket.OPEN) return;\r\n      await new Promise(r => setTimeout(r, interval));\r\n    }\r\n    throw new Error('WebSocket no disponible');\r\n  }\r\n\r\n  // REST\r\n  async fetchMenu() {\r\n    const r = await fetch(`${this.baseUrl}/dishes`);\r\n    return r.json();\r\n  }\r\n\r\n  async createOrder(order) {\r\n    const r = await fetch(`${this.baseUrl}/orders`, {\r\n      method: 'POST',\r\n      headers: {'Content-Type':'application/json'},\r\n      body: JSON.stringify(order),\r\n    });\r\n    if (!r.ok) throw new Error('REST /orders falló');\r\n    return r.json();\r\n  }\r\n\r\n  async completeOrder(orderId) {\r\n    const r = await fetch(`${this.baseUrl}/orders/${orderId}`, {\r\n      method: 'PATCH',\r\n      headers: {'Content-Type':'application/json'},\r\n      body: JSON.stringify({ status: 'completed' }),\r\n    });\r\n    if (!r.ok) throw new Error('REST /orders/:id falló');\r\n    return r.json();\r\n  }\r\n}\r\n\r\nexport const socket = SocketService.getInstance();\r\n\r\n/**\r\n * Inicializa subscripción por namespace.\r\n */\r\nexport const initializeSocketConnection = (namespace, onOrdersArray) => {\r\n  socket.on(`${namespace}:initial_data`, ({ orders }) => onOrdersArray?.(orders || []));\r\n  socket.on(`${namespace}:update`, ({ orders }) => onOrdersArray?.(orders || []));\r\n  socket.on(`${namespace}:new_order`, ({ order }) => {\r\n    onOrdersArray?.(Array.isArray(order) ? order : [order]);\r\n  });\r\n\r\n  socket.connect();\r\n};\r\n\r\nexport const fetchMenuItems = () => socket.fetchMenu();\r\n\r\n/** Enviar pedido */\r\nexport const placeNewOrderNS = async (namespace, order) => {\r\n  const saved = await socket.createOrder(order);\r\n  await socket.waitForSocketReady();\r\n  socket.send({\r\n    type: `${namespace}:new_order`,\r\n    order: [saved] // siempre array\r\n  });\r\n  return saved;\r\n};\r\n\r\n/** Marcar completado */\r\nexport const markOrderAsCompletedNS = async (namespace, orderId) => {\r\n  const updated = await socket.completeOrder(orderId); // pedido actualizado\r\n  await socket.waitForSocketReady();\r\n  socket.send({\r\n    type: `${namespace}:update`,\r\n    orders: [updated] // enviamos pedido actualizado\r\n  });\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}