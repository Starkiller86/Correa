{"ast":null,"code":"// services/socket.js\nclass SocketService {\n  static getInstance() {\n    if (!SocketService.instance) {\n      SocketService.instance = new SocketService();\n    }\n    return SocketService.instance;\n  }\n  constructor() {\n    this.socket = null;\n    this.callbacks = {};\n    this.retryCount = 0;\n    const hostname = window.location.hostname;\n    this.wsUrl = `ws://${hostname}:8080`; // WebSocket din√°mico\n    this.baseUrl = `http://${hostname}:3001`; // REST (json-server)\n  }\n  connect() {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\n    this.socket = new WebSocket(this.wsUrl);\n    this.socket.onopen = () => {\n      this.retryCount = 0;\n    };\n    this.socket.onmessage = msg => {\n      try {\n        const data = JSON.parse(msg.data);\n        const type = data === null || data === void 0 ? void 0 : data.type;\n        if (!type) return;\n\n        // Dispara handlers registrados exactamente por tipo\n        if (this.callbacks[type]) {\n          this.callbacks[type](data);\n          return;\n        }\n\n        // üîÅ Tolerancia: si llega `kitchen:new_order` o `bar:new_order`,\n        // convi√©rtelo a un \"update\" para quienes esperan arreglos.\n        if (type.endsWith(':new_order') && data.order) {\n          const ns = type.split(':')[0]; // 'kitchen' o 'bar'\n          const normalized = Array.isArray(data.order) ? data.order : [data.order];\n          const payload = {\n            type: `${ns}:update`,\n            orders: normalized\n          };\n          if (this.callbacks[payload.type]) {\n            this.callbacks[payload.type](payload);\n          }\n        }\n      } catch (e) {\n        console.error('‚ùå Error procesando mensaje WS:', e);\n      }\n    };\n    this.socket.onclose = () => this.scheduleReconnect();\n    this.socket.onerror = e => console.error('‚ö†Ô∏è WS error:', e);\n  }\n  scheduleReconnect() {\n    const delay = Math.min(1000 * 2 ** this.retryCount, 30000);\n    this.retryCount += 1;\n    setTimeout(() => this.connect(), delay);\n  }\n  on(type, cb) {\n    this.callbacks[type] = cb;\n  }\n  send(payload) {\n    var _this$socket;\n    if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(payload));\n    } else {\n      console.warn('WS no abierto, no se envi√≥:', payload);\n    }\n  }\n  async waitForSocketReady(retries = 6, interval = 400) {\n    for (let i = 0; i < retries; i++) {\n      var _this$socket2;\n      if (((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.readyState) === WebSocket.OPEN) return;\n      await new Promise(r => setTimeout(r, interval));\n    }\n    throw new Error('WebSocket no disponible');\n  }\n\n  // ===== REST (cocina)\n  async fetchMenu() {\n    const r = await fetch(`${this.baseUrl}/dishes`);\n    return r.json();\n  }\n  async createOrder(order) {\n    const r = await fetch(`${this.baseUrl}/orders`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(order)\n    });\n    if (!r.ok) throw new Error('REST /orders fall√≥');\n    return r.json();\n  }\n  async completeOrder(orderId) {\n    const r = await fetch(`${this.baseUrl}/orders/${orderId}`, {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        status: 'completed'\n      })\n    });\n    if (!r.ok) throw new Error('REST /orders/:id fall√≥');\n    return r.json();\n  }\n}\n\n// Singleton\nSocketService.instance = null;\nexport const socket = SocketService.getInstance();\n\n/** Inicializa subscripci√≥n POR NAMESPACE (ej: 'kitchen'). SIEMPRE entrega array. */\nexport const initializeSocketConnection = (namespace, onOrders) => {\n  socket.on(`${namespace}:initial_data`, ({\n    orders\n  }) => onOrders === null || onOrders === void 0 ? void 0 : onOrders(orders || []));\n  socket.on(`${namespace}:update`, ({\n    orders\n  }) => onOrders === null || onOrders === void 0 ? void 0 : onOrders(orders || []));\n  // üîÅ Tolerancia: si el server no reemite 'update' y solo manda ':new_order'\n  socket.on(`${namespace}:new_order`, ({\n    order\n  }) => onOrders === null || onOrders === void 0 ? void 0 : onOrders(Array.isArray(order) ? order : [order]));\n  socket.connect();\n};\n\n/** Fetch de men√∫ de cocina */\nexport const fetchMenuItems = () => socket.fetchMenu();\n\n/** Crear orden POR NAMESPACE (kitchen) */\nexport const placeNewOrderNS = async (namespace, order) => {\n  const saved = await socket.createOrder(order);\n  await socket.waitForSocketReady();\n  socket.send({\n    type: `${namespace}:new_order`,\n    order: saved\n  });\n  return saved;\n};\n\n/** Marcar completado POR NAMESPACE (kitchen) */\nexport const markOrderAsCompletedNS = async (namespace, orderId) => {\n  await socket.completeOrder(orderId);\n  await socket.waitForSocketReady();\n  socket.send({\n    type: `${namespace}:complete_order`,\n    orderId\n  });\n};","map":{"version":3,"names":["SocketService","getInstance","instance","constructor","socket","callbacks","retryCount","hostname","window","location","wsUrl","baseUrl","connect","readyState","WebSocket","OPEN","onopen","onmessage","msg","data","JSON","parse","type","endsWith","order","ns","split","normalized","Array","isArray","payload","orders","e","console","error","onclose","scheduleReconnect","onerror","delay","Math","min","setTimeout","on","cb","send","_this$socket","stringify","warn","waitForSocketReady","retries","interval","i","_this$socket2","Promise","r","Error","fetchMenu","fetch","json","createOrder","method","headers","body","ok","completeOrder","orderId","status","initializeSocketConnection","namespace","onOrders","fetchMenuItems","placeNewOrderNS","saved","markOrderAsCompletedNS"],"sources":["C:/Users/karen/OneDrive/Escritorio/Correa3/Correa/client/src/services/socket.js"],"sourcesContent":["// services/socket.js\r\nclass SocketService {\r\n  static instance = null;\r\n\r\n  static getInstance() {\r\n    if (!SocketService.instance) {\r\n      SocketService.instance = new SocketService();\r\n    }\r\n    return SocketService.instance;\r\n  }\r\n\r\n  constructor() {\r\n    this.socket = null;\r\n    this.callbacks = {};\r\n    this.retryCount = 0;\r\n\r\n    const hostname = window.location.hostname;\r\n    this.wsUrl = `ws://${hostname}:8080`; // WebSocket din√°mico\r\n    this.baseUrl = `http://${hostname}:3001`; // REST (json-server)\r\n  }\r\n\r\n  connect() {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\r\n    this.socket = new WebSocket(this.wsUrl);\r\n\r\n    this.socket.onopen = () => {\r\n      this.retryCount = 0;\r\n    };\r\n\r\n    this.socket.onmessage = (msg) => {\r\n      try {\r\n        const data = JSON.parse(msg.data);\r\n        const type = data?.type;\r\n        if (!type) return;\r\n\r\n        // Dispara handlers registrados exactamente por tipo\r\n        if (this.callbacks[type]) {\r\n          this.callbacks[type](data);\r\n          return;\r\n        }\r\n\r\n        // üîÅ Tolerancia: si llega `kitchen:new_order` o `bar:new_order`,\r\n        // convi√©rtelo a un \"update\" para quienes esperan arreglos.\r\n        if (type.endsWith(':new_order') && data.order) {\r\n          const ns = type.split(':')[0]; // 'kitchen' o 'bar'\r\n          const normalized = Array.isArray(data.order) ? data.order : [data.order];\r\n          const payload = { type: `${ns}:update`, orders: normalized };\r\n          if (this.callbacks[payload.type]) {\r\n            this.callbacks[payload.type](payload);\r\n          }\r\n        }\r\n      } catch (e) {\r\n        console.error('‚ùå Error procesando mensaje WS:', e);\r\n      }\r\n    };\r\n\r\n    this.socket.onclose = () => this.scheduleReconnect();\r\n    this.socket.onerror = (e) => console.error('‚ö†Ô∏è WS error:', e);\r\n  }\r\n\r\n  scheduleReconnect() {\r\n    const delay = Math.min(1000 * (2 ** this.retryCount), 30000);\r\n    this.retryCount += 1;\r\n    setTimeout(() => this.connect(), delay);\r\n  }\r\n\r\n  on(type, cb) { this.callbacks[type] = cb; }\r\n\r\n  send(payload) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify(payload));\r\n    } else {\r\n      console.warn('WS no abierto, no se envi√≥:', payload);\r\n    }\r\n  }\r\n\r\n  async waitForSocketReady(retries = 6, interval = 400) {\r\n    for (let i = 0; i < retries; i++) {\r\n      if (this.socket?.readyState === WebSocket.OPEN) return;\r\n      await new Promise(r => setTimeout(r, interval));\r\n    }\r\n    throw new Error('WebSocket no disponible');\r\n  }\r\n\r\n  // ===== REST (cocina)\r\n  async fetchMenu() {\r\n    const r = await fetch(`${this.baseUrl}/dishes`);\r\n    return r.json();\r\n  }\r\n  async createOrder(order) {\r\n    const r = await fetch(`${this.baseUrl}/orders`, {\r\n      method: 'POST',\r\n      headers: {'Content-Type':'application/json'},\r\n      body: JSON.stringify(order),\r\n    });\r\n    if (!r.ok) throw new Error('REST /orders fall√≥');\r\n    return r.json();\r\n  }\r\n  async completeOrder(orderId) {\r\n    const r = await fetch(`${this.baseUrl}/orders/${orderId}`, {\r\n      method: 'PATCH',\r\n      headers: {'Content-Type':'application/json'},\r\n      body: JSON.stringify({ status: 'completed' }),\r\n    });\r\n    if (!r.ok) throw new Error('REST /orders/:id fall√≥');\r\n    return r.json();\r\n  }\r\n}\r\n\r\n// Singleton\r\nexport const socket = SocketService.getInstance();\r\n\r\n/** Inicializa subscripci√≥n POR NAMESPACE (ej: 'kitchen'). SIEMPRE entrega array. */\r\nexport const initializeSocketConnection = (namespace, onOrders) => {\r\n  socket.on(`${namespace}:initial_data`, ({ orders }) => onOrders?.(orders || []));\r\n  socket.on(`${namespace}:update`,       ({ orders }) => onOrders?.(orders || []));\r\n  // üîÅ Tolerancia: si el server no reemite 'update' y solo manda ':new_order'\r\n  socket.on(`${namespace}:new_order`,    ({ order })  => onOrders?.(Array.isArray(order) ? order : [order]));\r\n  socket.connect();\r\n};\r\n\r\n/** Fetch de men√∫ de cocina */\r\nexport const fetchMenuItems = () => socket.fetchMenu();\r\n\r\n/** Crear orden POR NAMESPACE (kitchen) */\r\nexport const placeNewOrderNS = async (namespace, order) => {\r\n  const saved = await socket.createOrder(order);\r\n  await socket.waitForSocketReady();\r\n  socket.send({ type: `${namespace}:new_order`, order: saved });\r\n  return saved;\r\n};\r\n\r\n/** Marcar completado POR NAMESPACE (kitchen) */\r\nexport const markOrderAsCompletedNS = async (namespace, orderId) => {\r\n  await socket.completeOrder(orderId);\r\n  await socket.waitForSocketReady();\r\n  socket.send({ type: `${namespace}:complete_order`, orderId });\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}