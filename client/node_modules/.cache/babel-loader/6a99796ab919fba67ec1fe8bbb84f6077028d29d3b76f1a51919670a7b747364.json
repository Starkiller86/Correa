{"ast":null,"code":"// src/services/socket.js\n// ✅ Socket genérico para cocina/cliente + helpers de menú en tiempo real\nclass SocketService {\n  static getInstance() {\n    if (!SocketService.instance) {\n      SocketService.instance = new SocketService();\n    }\n    return SocketService.instance;\n  }\n  constructor() {\n    // URLs dinámicas según el host donde se abre el front\n    const host = window.location.hostname;\n    this.wsUrl = `ws://${host}:8080`;\n    this.baseUrl = `http://${host}:3001`;\n    this.socket = null;\n    this.retryCount = 0;\n\n    // Handlers registrados: { eventType: [fn, fn, ...] }\n    this.handlers = {\n      initial_data: [],\n      update: [],\n      menu_updated: [] // 🚨 avisos de admin (dishes)\n    };\n  }\n\n  // Conexión WS con reintentos exponenciales\n  connect() {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\n    this.socket = new WebSocket(this.wsUrl);\n    this.socket.onopen = () => {\n      console.log('✅ [socket] Conectado:', this.wsUrl);\n      this.retryCount = 0;\n    };\n    this.socket.onmessage = evt => {\n      var _data;\n      let data;\n      try {\n        data = JSON.parse(evt.data);\n      } catch (e) {\n        console.error('❌ [socket] Mensaje inválido:', evt.data);\n        return;\n      }\n      const t = (_data = data) === null || _data === void 0 ? void 0 : _data.type;\n      if (!t) return;\n\n      // Disparamos todos los listeners para ese tipo\n      (this.handlers[t] || []).forEach(fn => {\n        try {\n          fn(data);\n        } catch (e) {\n          console.error('Handler error', e);\n        }\n      });\n\n      // Compatibilidad: algunos clientes esperan que 'initial_data'/'update'\n      // lleven un array de órdenes\n      if ((t === 'initial_data' || t === 'update') && Array.isArray(data.orders)) {\n        // Nada extra, ya lo reciben quienes se suscriben\n      }\n    };\n    this.socket.onclose = () => {\n      console.warn('🔌 [socket] Desconectado, reintentando...');\n      this.scheduleReconnect();\n    };\n    this.socket.onerror = err => {\n      console.error('⚠️ [socket] Error:', err);\n    };\n  }\n  scheduleReconnect() {\n    const delay = Math.min(1000 * 2 ** this.retryCount, 30000);\n    this.retryCount += 1;\n    setTimeout(() => this.connect(), delay);\n  }\n  on(type, cb) {\n    if (!this.handlers[type]) this.handlers[type] = [];\n    this.handlers[type].push(cb);\n  }\n  send(obj) {\n    var _this$socket;\n    if (((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState) === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(obj));\n    } else {\n      console.error('🚫 [socket] No conectado — no se envía', obj);\n    }\n  }\n\n  // ---------------- REST: Cocina/Cliente ----------------\n  async fetchMenu() {\n    const r = await fetch(`${this.baseUrl}/dishes`);\n    return r.json();\n  }\n  async createOrder(order) {\n    // Guarda en JSON Server (colección /orders)\n    const r = await fetch(`${this.baseUrl}/orders`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(order)\n    });\n    return r.json();\n  }\n  async completeOrder(orderId) {\n    const r = await fetch(`${this.baseUrl}/orders/${orderId}`, {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        status: 'completed'\n      })\n    });\n    return r.json();\n  }\n\n  // ---------------- Señales de admin ----------------\n  notifyMenuUpdated() {\n    // Emite un \"ping\" para que todos refetchen dishes\n    this.send({\n      type: 'menu_updated'\n    });\n  }\n}\nSocketService.instance = null;\nexport const socket = SocketService.getInstance();\n\n// Suscribe cocina/cliente a órdenes + eventos admin de menú\nexport const initializeSocketConnection = onOrders => {\n  socket.on('initial_data', d => onOrders === null || onOrders === void 0 ? void 0 : onOrders(d.orders || []));\n  socket.on('update', d => onOrders === null || onOrders === void 0 ? void 0 : onOrders(d.orders || []));\n  // Para refrescar menú en tiempo real\n  socket.on('menu_updated', () => {\n    // Simplemente dejamos que quien lo use haga un refetch cuando lo reciba\n    // (ver ClientInterface.jsx)\n    onOrders === null || onOrders === void 0 ? void 0 : onOrders('__MENU_UPDATED__'); // banderita por si quieres manejarlo\n  });\n  socket.connect();\n};\n\n// REST helpers\nexport const fetchMenuItems = () => socket.fetchMenu();\nexport const placeNewOrder = async order => {\n  // Guarda y luego notifica al WS\n  const saved = await socket.createOrder(order);\n  socket.send({\n    type: 'new_order',\n    order: saved\n  });\n  return saved;\n};\nexport const markOrderAsCompleted = async orderId => {\n  const updated = await socket.completeOrder(orderId);\n  socket.send({\n    type: 'complete_order',\n    orderId\n  });\n  return updated;\n};\n\n// Señal de admin (para MenuAdmin.jsx)\nexport const notifyMenuUpdated = () => socket.notifyMenuUpdated();","map":{"version":3,"names":["SocketService","getInstance","instance","constructor","host","window","location","hostname","wsUrl","baseUrl","socket","retryCount","handlers","initial_data","update","menu_updated","connect","readyState","WebSocket","OPEN","onopen","console","log","onmessage","evt","_data","data","JSON","parse","e","error","t","type","forEach","fn","Array","isArray","orders","onclose","warn","scheduleReconnect","onerror","err","delay","Math","min","setTimeout","on","cb","push","send","obj","_this$socket","stringify","fetchMenu","r","fetch","json","createOrder","order","method","headers","body","completeOrder","orderId","status","notifyMenuUpdated","initializeSocketConnection","onOrders","d","fetchMenuItems","placeNewOrder","saved","markOrderAsCompleted","updated"],"sources":["C:/Users/karen/OneDrive/Escritorio/Correa3/coorrea/Correa/client/src/services/socket.js"],"sourcesContent":["// src/services/socket.js\r\n// ✅ Socket genérico para cocina/cliente + helpers de menú en tiempo real\r\nclass SocketService {\r\n  static instance = null;\r\n\r\n  static getInstance() {\r\n    if (!SocketService.instance) {\r\n      SocketService.instance = new SocketService();\r\n    }\r\n    return SocketService.instance;\r\n  }\r\n\r\n  constructor() {\r\n    // URLs dinámicas según el host donde se abre el front\r\n    const host = window.location.hostname;\r\n    this.wsUrl = `ws://${host}:8080`;\r\n    this.baseUrl = `http://${host}:3001`;\r\n\r\n    this.socket = null;\r\n    this.retryCount = 0;\r\n\r\n    // Handlers registrados: { eventType: [fn, fn, ...] }\r\n    this.handlers = {\r\n      initial_data: [],\r\n      update: [],\r\n      menu_updated: [],     // 🚨 avisos de admin (dishes)\r\n    };\r\n  }\r\n\r\n  // Conexión WS con reintentos exponenciales\r\n  connect() {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) return;\r\n\r\n    this.socket = new WebSocket(this.wsUrl);\r\n\r\n    this.socket.onopen = () => {\r\n      console.log('✅ [socket] Conectado:', this.wsUrl);\r\n      this.retryCount = 0;\r\n    };\r\n\r\n    this.socket.onmessage = (evt) => {\r\n      let data;\r\n      try {\r\n        data = JSON.parse(evt.data);\r\n      } catch (e) {\r\n        console.error('❌ [socket] Mensaje inválido:', evt.data);\r\n        return;\r\n      }\r\n\r\n      const t = data?.type;\r\n      if (!t) return;\r\n\r\n      // Disparamos todos los listeners para ese tipo\r\n      (this.handlers[t] || []).forEach(fn => {\r\n        try { fn(data); } catch (e) { console.error('Handler error', e); }\r\n      });\r\n\r\n      // Compatibilidad: algunos clientes esperan que 'initial_data'/'update'\r\n      // lleven un array de órdenes\r\n      if ((t === 'initial_data' || t === 'update') && Array.isArray(data.orders)) {\r\n        // Nada extra, ya lo reciben quienes se suscriben\r\n      }\r\n    };\r\n\r\n    this.socket.onclose = () => {\r\n      console.warn('🔌 [socket] Desconectado, reintentando...');\r\n      this.scheduleReconnect();\r\n    };\r\n\r\n    this.socket.onerror = (err) => {\r\n      console.error('⚠️ [socket] Error:', err);\r\n    };\r\n  }\r\n\r\n  scheduleReconnect() {\r\n    const delay = Math.min(1000 * (2 ** this.retryCount), 30000);\r\n    this.retryCount += 1;\r\n    setTimeout(() => this.connect(), delay);\r\n  }\r\n\r\n  on(type, cb) {\r\n    if (!this.handlers[type]) this.handlers[type] = [];\r\n    this.handlers[type].push(cb);\r\n  }\r\n\r\n  send(obj) {\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify(obj));\r\n    } else {\r\n      console.error('🚫 [socket] No conectado — no se envía', obj);\r\n    }\r\n  }\r\n\r\n  // ---------------- REST: Cocina/Cliente ----------------\r\n  async fetchMenu() {\r\n    const r = await fetch(`${this.baseUrl}/dishes`);\r\n    return r.json();\r\n  }\r\n\r\n  async createOrder(order) {\r\n    // Guarda en JSON Server (colección /orders)\r\n    const r = await fetch(`${this.baseUrl}/orders`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(order),\r\n    });\r\n    return r.json();\r\n  }\r\n\r\n  async completeOrder(orderId) {\r\n    const r = await fetch(`${this.baseUrl}/orders/${orderId}`, {\r\n      method: 'PATCH',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ status: 'completed' }),\r\n    });\r\n    return r.json();\r\n  }\r\n\r\n  // ---------------- Señales de admin ----------------\r\n  notifyMenuUpdated() {\r\n    // Emite un \"ping\" para que todos refetchen dishes\r\n    this.send({ type: 'menu_updated' });\r\n  }\r\n}\r\n\r\nexport const socket = SocketService.getInstance();\r\n\r\n// Suscribe cocina/cliente a órdenes + eventos admin de menú\r\nexport const initializeSocketConnection = (onOrders) => {\r\n  socket.on('initial_data', d => onOrders?.(d.orders || []));\r\n  socket.on('update', d => onOrders?.(d.orders || []));\r\n  // Para refrescar menú en tiempo real\r\n  socket.on('menu_updated', () => {\r\n    // Simplemente dejamos que quien lo use haga un refetch cuando lo reciba\r\n    // (ver ClientInterface.jsx)\r\n    onOrders?.('__MENU_UPDATED__'); // banderita por si quieres manejarlo\r\n  });\r\n  socket.connect();\r\n};\r\n\r\n// REST helpers\r\nexport const fetchMenuItems = () => socket.fetchMenu();\r\nexport const placeNewOrder = async (order) => {\r\n  // Guarda y luego notifica al WS\r\n  const saved = await socket.createOrder(order);\r\n  socket.send({ type: 'new_order', order: saved });\r\n  return saved;\r\n};\r\nexport const markOrderAsCompleted = async (orderId) => {\r\n  const updated = await socket.completeOrder(orderId);\r\n  socket.send({ type: 'complete_order', orderId });\r\n  return updated;\r\n};\r\n\r\n// Señal de admin (para MenuAdmin.jsx)\r\nexport const notifyMenuUpdated = () => socket.notifyMenuUpdated();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}